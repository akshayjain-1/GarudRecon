#!/bin/bash

MODULES_DIR="modules"
TOOL="$1"
shift

VERBOSE=false

# Help function
function show_help() {
  cat <<EOF
Run workflow scan (e.g. 1 vuln on all programs like mass vuln scan).

Usage:
  garudrecon workflow [flags]

Flags:
  -i, --input       Pass the input
  -o, --output      Location where you want to save output
  -v, --verbose     enable verbose mode
  -h, --help        help for modules

Example:
  garudrecon workflow amass --input <domain> --output <file> [--verbose]
  garudrecon workflow ls
  garudrecon workflow ls [module]
  garudrecon workflow cat [module]
  garudrecon workflow add [module]
  garudrecon workflow edit [module]
  garudrecon workflow delete [module]
EOF
}

print_table() {
  modules=("$@")

  # collect rows
  rows=()
  rows+=("MODULES|USAGE EXAMPLES|DESCRIPTION")

  for module in "${modules[@]}"; do
    example=$(jq -r '.[0].example' "$MODULES_DIR/$module")
    description=$(jq -r '.[0].description' "$MODULES_DIR/$module")

    rows+=("$module|$example|$description")
  done

  # calculate max width for each column
  col1=$(printf "%s\n" "${rows[@]}" | cut -d'|' -f1 | awk '{print length}' | sort -nr | head -1)
  col2=$(printf "%s\n" "${rows[@]}" | cut -d'|' -f2 | awk '{print length}' | sort -nr | head -1)
  col3=$(printf "%s\n" "${rows[@]}" | cut -d'|' -f3 | awk '{print length}' | sort -nr | head -1)

  # print header
  IFS="|" read -r c1 c2 c3 <<< "${rows[0]}"
  printf "| %-${col1}s | %-${col2}s | %-${col3}s |\n" "$c1" "$c2" "$c3"
  printf "|-%-${col1}s-|-%-${col2}s-|-%-${col3}s-|\n" "$(printf '─%.0s' $(seq 1 $col1))" "$(printf '─%.0s' $(seq 1 $col2))" "$(printf '─%.0s' $(seq 1 $col3))"

  # print rows
  for ((i=1; i<${#rows[@]}; i++)); do
    IFS="|" read -r c1 c2 c3 <<< "${rows[$i]}"
    printf "| %-${col1}s | %-${col2}s | %-${col3}s |\n" "$c1" "$c2" "$c3"
  done
}

if [[ "$TOOL" == "ls" ]]; then
  if [[ -n "$1" ]]; then
    # list single module
    if [[ -f "$MODULES_DIR/$1.json" ]]; then
      print_table "$1.json"
    else
      echo "Module '$1' not found."
      exit 1
    fi
  else
    # list all modules
    modules=($(ls "$MODULES_DIR"/*.json | xargs -n1 basename))
    print_table "${modules[@]}"
  fi
  exit 0
fi

if [[ "$TOOL" == "cat" ]]; then
  if [[ -n "$1" ]]; then
    MODULE_FILE="$MODULES_DIR/$1.json"

    if [[ -f "$MODULE_FILE" ]]; then
      cat "$MODULE_FILE"
    else
      echo "Module '$MODULE_FILE' not found."
      exit 1
    fi
  else
    echo "No module name provided."
    exit 1
  fi
  exit 0
fi


if [[ "$TOOL" == "add" ]]; then
  if [[ -n "$1" ]]; then
    MODULE_FILE="$MODULES_DIR/$1.json"

    # create modules dir if it doesn't exist
    mkdir -p "$MODULES_DIR"

    if [[ -f "$MODULE_FILE" ]]; then
      echo "Module '$MODULE_FILE' already exists."
    else
      # create a new json file with basic structure
      cat > "$MODULE_FILE" <<EOF
[{
  "requirements": [
    { "bin": "", "install": "" }
  ],
  "command": [
    ""
  ],
  "example": "",
  "description": ""
}]
EOF
      echo "Created new module: $MODULE_FILE"
    fi
  else
    echo "No module name provided."
    exit 1
  fi
  exit 0
fi

if [[ "$TOOL" == "edit" ]]; then
  if [[ -n "$1" ]]; then
    MODULE_FILE="$MODULES_DIR/$1.json"

    # create modules dir if missing
    mkdir -p "$MODULES_DIR"

    # if file doesn't exist, create an empty json
    if [[ ! -f "$MODULE_FILE" ]]; then
      echo "Module '$MODULE_FILE' not found."
    fi

    # open in nano
    nano "$MODULE_FILE"
  else
    echo "No module name provided."
    exit 1
  fi
  exit 0
fi

if [[ "$TOOL" == "delete" ]]; then
  if [[ -n "$1" ]]; then
    MODULE_FILE="$MODULES_DIR/$1.json"

    if [[ -f "$MODULE_FILE" ]]; then
      rm -rf "$MODULE_FILE"
      echo "Module '$MODULE_FILE' deleted."
    else
      echo "Module '$MODULE_FILE' not found."
      exit 1
    fi
  else
    echo "No module name provided."
    exit 1
  fi
  exit 0
fi


# --- normal module execution ---
# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -i|--input)
      INPUT="$2"
      shift 2
      ;;
    -o|--output)
      OUTPUT="$2"
      shift 2
      ;;
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Check required args
if [[ -z "$INPUT" || -z "$OUTPUT" ]]; then
  echo "Error: --input and --output are required"
  show_help
  exit 1
fi

# --- check requirements ---
REQUIREMENTS=$(jq -c '.[0].requirements[]?' "$MODULES_DIR/$TOOL.json")

check_requirements() {
  local req="$1"
  local bin install

  bin=$(echo "$req" | jq -r '.bin')
  install=$(echo "$req" | jq -r '.install')

  if ! command -v "$bin" &>/dev/null; then
    if $VERBOSE; then
      echo "[!] $bin not installed. Installing..."
    fi
    eval "$install"
    if ! command -v "$bin" &>/dev/null; then
      echo "[x] Failed to install $bin, please install manually."
      exit 1
    fi
    if $VERBOSE; then
      echo "[+] $bin installed successfully."
    fi
  else
    if $VERBOSE; then
      echo "[*] $bin already installed."
    fi
  fi
}

# loop through requirements
while IFS= read -r req; do
  check_requirements "$req"
done <<< "$REQUIREMENTS"


# Get commands (can be single string or array)
COMMANDS=$(jq -r '.[0].command[]?' "$MODULES_DIR/$TOOL.json")

# Run each command after replacing placeholders
while IFS= read -r CMD; do
  CMD="${CMD//\$\{INPUT\}/$INPUT}"
  CMD="${CMD//\$\{OUTPUT\}/$OUTPUT}"

  if $VERBOSE; then
    echo "[*] Running: $CMD"
  fi

  eval "$CMD"
done <<< "$COMMANDS"
